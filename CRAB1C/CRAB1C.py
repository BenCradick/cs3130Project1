import timeit
##Copy of CRAB1A/B

ITERATIONS = 1
def fibonacci_iterative(k) :
    penultimate = 0
    last = 0
    current = 1
    while( k > 1 ):
        penultimate = last
        #Calculate next fibonacci number in sequence F(n-2)+F(n-1)
        last = current
        ##Temporary numbers
        current = last + penultimate
        ##Assign F(n) to F(n-1)
        
        #print(k, current)
        ##decrement counter
        k -= 1
    return current

def fibonacci_recursive(k, current, last) :
    if k > 1 : 
        temp = current + last    
        k = k - 1
        return fibonacci_recursive(k, temp, current)
    else : 
        return current


results = open("CRAB1C/results.txt", "w")
print(f"N,Recursive,Iterative", file=results)

## two column matrix stores values that get generated by timeit for each value of F(n) with 1000 runs each
iterative=[0 for x in range(0,996)]
recursive=[0 for x in range(0,996)]
try:
    for i in range (1, 995):
            
            iterative_call = f"{fibonacci_iterative(i)}"
            recursive_call = f"{fibonacci_recursive(i,1,0)}"
            #setup = f"from __main__ import Fibonacci_Numbers;FibNums=Fibonacci_Numbers({i})"
            iterative[i-1] = timeit.Timer(setup="from __main__ import fibonacci_iterative", stmt=iterative_call).repeat(10000,1)
            recursive[i-1] = timeit.Timer(setup="from __main__ import fibonacci_recursive", stmt=recursive_call).repeat(10000,1)
except RecursionError:
    print(i,k)


for k in range (1,995): 
    rec_min = min(recursive[k-1])
    print(f"{k}, {rec_min}, {min(iterative[k-1])}", file=results)