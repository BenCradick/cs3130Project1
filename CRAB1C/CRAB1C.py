import timeit
##Copy of CRAB1A/B

ITERATIONS = 10000
class Fibonacci_Numbers:
    def __init__(self, k):
        ## k represents iterations to perform.
        ## The initial value of k is also the location of the F(k) we are trying to find.
        ## last = F(k-1)
        self.last = 0
        self.current = 1
        self.count = k
    ## F(n) = F(n-1) + F(n-2)s
    def fibonacci_iterative(self) :
        while( self.count > 1 ):
            ##Temporary numbers
            temp = self.current + self.last
            ##Assign F(n) to F(n-1)
            self.last = self.current
            #Calculate next fibonacci number in sequence F(n-2)+F(n-1)
            self.current = temp
            ##decrement counter
            self.count = self.count - 1
        return self.current

def fibonacci_recursive(k, current, last) :
    if k > 1 : 
        temp = current + last    
        k = k - 1
        return fibonacci_recursive(k, temp, current)
    else : 
        return current

def fib_helper(k) :
    return fibonacci_recursive(k, 1, 0)

results = open("CRAB1C/results.txt", "w")
print(f"N,Recursive,Iterative", file=results)

## two column matrix stores values that get generated by timeit for each value of F(n) with 1000 runs each
iterative=[[0 for y in range(0,ITERATIONS)]for x in range(0,996)]
recursive=[[0 for y in range(0,ITERATIONS)]for x in range(0,996)]
try:
    for i in range (1, 995):
        for k in range(0,ITERATIONS):
            FibNum = Fibonacci_Numbers(i)
            call = f"{FibNum.fibonacci_iterative()}"
            #setup = f"from __main__ import Fibonacci_Numbers;FibNums=Fibonacci_Numbers({i})"
            iterative[i-1][k] = timeit.timeit(setup="from __main__ import Fibonacci_Numbers", stmt=call, number=1)
            recursive[i-1][k] = timeit.timeit(setup="from __main__ import fib_helper", stmt=f"fib_helper({i})", number=1)
except RecursionError:
    print(i,k)
for k in range (1,995):
    rec_min = min(recursive[k-1])
    print(f"{k}, {rec_min}, {min(iterative[k-1])}", file=results)